### Архитектура ИИ: AICoordinator, MovementSystem, AttackSystem

Этот документ описывает роли и взаимодействие ключевых компонентов ИИ:
`AICoordinator`, `MovementSystem`, `AttackSystem`, а также общие правила конфигурации и расчётов.

### Обзор ролей

- **AICoordinator**: координирует все системы ИИ конкретного объекта.
  - Держит текущую цель (`currentTarget`) и состояние ИИ (`idle`, `moving`, `attacking`, `pathfinding`).
  - Создаёт и обновляет системы: `MovementSystem`, `AttackSystem`, `CollisionSystem`, `PathfindingSystem`.
  - На каждом апдейте выбирает, что делать: атаковать, искать путь или двигаться к цели.

- **MovementSystem**: отвечает за перемещение к цели.
  - Поддерживает разные стратегии движения (линейная, инерционная, прыжковая, спавнер и т.д.).
  - Рассчитывает момент остановки на основе эффективного радиуса до цели (см. Ниже).
  - Умеет двигаться по пути, обновлять скорость/поворот и эмитить события движения.

- **AttackSystem**: отвечает за атаки по цели.
  - Поддерживает разные стратегии атаки (`simple`, `spawn`, `singleUse`, …).
  - Решение «можно ли атаковать сейчас» принимает по кулдауну и эффективному радиусу.
  - Выполняет атаку, эмитит события и управляет состоянием атаки.

### Поток данных и целеполагание

1) Конфигурация врага собирается в `SystemConfig` (через адаптеры) и передаётся в `AICoordinator`.
2) Внешние системы (или геймплей) устанавливают цель для `AICoordinator.setTarget(target)`.
3) Координатор прокидывает цель в `MovementSystem` и `AttackSystem` (если стратегия движения требует внешнюю цель).
4) На каждом апдейте `AICoordinator`:
   - Если цель в радиусе атаки → состояние `attacking` → `AttackSystem.attack()`.
   - Иначе, если нужно, запрашивает путь у `PathfindingSystem` и двигается по нему.
   - Иначе — двигается напрямую через `MovementSystem.moveTo(target)`.

### Конфигурация (SystemConfig)

- `SystemConfig` агрегирует источники с приоритетом «последний источник важнее», поддерживает вложенные `SystemConfig` и кеширование.
- Доступ к значениям производится через `config.get(path, defaultValue)`.
- Системы/стратегии получают параметры только из `SystemConfig` (принцип единого источника правды).

Ключевые секции:
- `movement.*` — стратегия движения и её параметры (скорости, поворот, колебания и т.д.).
- `attack.*` — стратегия атаки, `cooldown`, `damage`, `range`.

### Единые правила расстояний

- Базовый радиус атаки берётся только из `attack.range`.
- Эффективный радиус рассчитывается через `GeometryUtils.effectiveAttackRange(attacker, target, baseRange)`:
  - `effectiveRange = baseRange + attackerWidth/2 + targetWidth/2`
  - Ширины берутся через `GeometryUtils.getObjectSize(obj)` (приоритет: `displayWidth` → `body.width` → `getSizeInPixels()` → логический размер).
- Отрицательный `attack.range` допустим и уменьшает эффективную дистанцию (возможен визуальный оверлап спрайтов при работающей атаке).

Синхронизация:
- И `MovementSystem`, и `AttackSystem` используют один и тот же расчёт эффективного радиуса, чтобы момент остановки совпадал с возможностью атаки.

### Стратегии движения

- Стратегии создаются и настраиваются в `MovementSystem` по `movement.strategy`.
- Стратегии, которые опираются на внешнюю цель (например, `linear`), получают её через `strategy.setTarget(target)` из `MovementSystem.moveTo(target)`.
- Стратегии, работающие автономно (`randomPoint`, `spawner`), игнорируют внешнюю цель — координатор это учитывает.

### Стратегии атаки

- Выбор стратегии в `AttackSystem` по `attack.strategy`.
- При неизвестной стратегии происходит фоллбек на `simple` с предупреждением в консоль.
- Атака возможна только при соблюдении кулдауна и если цель в эффективном радиусе.

### События

- Системы эмитят события через `scene.events` с неймспейсами: `ai:*`, `movement:*`, `attack:*`.
- `AICoordinator` слушает события систем (например, `movement:targetReached`) и переводит ИИ в соответствующее состояние.

### Взаимодействие с внешними механиками (пример: «сахар/пончик»)

- Сторонние системы (например, `GestureActionSystem`) могут временно менять цель у врагов (на защитный объект).
- После уничтожения объекта-защиты цель должна быть восстановлена (`enemy._originalTarget` или яйцо).
- Для корректной работы нужно использовать актуальные коллекции объектов (например, живой список врагов сцены).

### Принципы и лучшие практики

- DRY: расчёты расстояний/размеров — только в `GeometryUtils`.
- Единая конфигурация: параметры только через `SystemConfig`.
- Чёткие роли: координатор — про выбор действия, системы — про реализацию, стратегии — про вариативность поведения.
- События/состояния — минимально необходимые, с неймспейсами и единым стилем именования.


